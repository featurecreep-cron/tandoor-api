name: Build and Publish Tandoor Client

on:
  schedule:
    - cron: "0 6 * * *"
  workflow_dispatch:
    inputs:
      force:
        description: "Force rebuild even if no changes detected"
        required: false
        type: boolean
        default: false

# Required repo variables (Settings > Secrets and variables > Actions > Variables):
#   UPSTREAM_REPO  - e.g. TandoorRecipes/recipes
#   UPSTREAM_URL   - e.g. https://github.com/TandoorRecipes/recipes.git

permissions:
  contents: write
  id-token: write

jobs:
  detect-new-tags:
    runs-on: ubuntu-latest
    outputs:
      tags: ${{ steps.find.outputs.tags }}
      has_tags: ${{ steps.find.outputs.has_tags }}
      latest_tag: ${{ steps.find.outputs.latest_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Find unprocessed upstream tags
        id: find
        run: |
          set -euo pipefail

          UPSTREAM="${{ vars.UPSTREAM_URL }}"
          FORCE="${{ inputs.force || 'false' }}"
          STORED_TAG=$(jq -r '.last_tag // "0.0.0"' upstream_state.json)

          echo "Stored tag: $STORED_TAG"

          # Get all semver tags from upstream
          all_tags=$(git ls-remote --tags "$UPSTREAM" | \
            grep -oP 'refs/tags/\K[0-9]+\.[0-9]+(\.[0-9]+)?$' | \
            sort -t. -k1,1n -k2,2n -k3,3n)

          if [ -z "$all_tags" ]; then
            echo "No upstream tags found"
            echo "has_tags=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Normalize stored tag to 3 components for comparison
          IFS='.' read -r smaj smin spat <<< "$STORED_TAG"
          spat="${spat:-0}"

          # Find tags newer than stored
          new_tags=()
          for tag in $all_tags; do
            IFS='.' read -r maj min pat <<< "$tag"
            pat="${pat:-0}"

            # Compare: major, then minor, then patch
            if [ "$maj" -gt "$smaj" ] || \
               { [ "$maj" -eq "$smaj" ] && [ "$min" -gt "$smin" ]; } || \
               { [ "$maj" -eq "$smaj" ] && [ "$min" -eq "$smin" ] && [ "$pat" -gt "$spat" ]; }; then
              new_tags+=("$tag")
            fi
          done

          if [ "$FORCE" = "true" ] && [ ${#new_tags[@]} -eq 0 ]; then
            # Force with no new tags: rebuild the stored tag
            latest=$(echo "$all_tags" | tail -1)
            echo "Force rebuild of $latest"
            echo "tags=[\"$latest\"]" >> "$GITHUB_OUTPUT"
            echo "has_tags=true" >> "$GITHUB_OUTPUT"
            echo "latest_tag=$latest" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ ${#new_tags[@]} -eq 0 ]; then
            echo "No new tags"
            echo "has_tags=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build JSON array
          json="["
          for i in "${!new_tags[@]}"; do
            [ "$i" -gt 0 ] && json+=","
            json+="\"${new_tags[$i]}\""
          done
          json+="]"

          latest="${new_tags[-1]}"
          echo "New tags: $json"
          echo "tags=$json" >> "$GITHUB_OUTPUT"
          echo "has_tags=true" >> "$GITHUB_OUTPUT"
          echo "latest_tag=$latest" >> "$GITHUB_OUTPUT"

  build-and-publish:
    needs: detect-new-tags
    if: needs.detect-new-tags.outputs.has_tags == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        tag: ${{ fromJSON(needs.detect-new-tags.outputs.tags) }}
      max-parallel: 2
      fail-fast: false

    env:
      DB_ENGINE: django.db.backends.sqlite3
      SECRET_KEY: not-a-real-secret-just-for-schema-generation
      ALLOWED_HOSTS: '*'

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          path: publisher

      - name: Checkout upstream at ${{ matrix.tag }}
        uses: actions/checkout@v4
        with:
          repository: ${{ vars.UPSTREAM_REPO }}
          ref: ${{ matrix.tag }}
          path: upstream

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Compute version
        id: version
        run: |
          cd publisher
          VERSION=$(python scripts/compute_version.py \
            --state-file upstream_state.json \
            --upstream-url "${{ vars.UPSTREAM_URL }}" \
            --tag "${{ matrix.tag }}")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Version: $VERSION"

      - name: Check if version exists on PyPI
        id: check-pypi
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/tandoor-client/${VERSION}/json")
          if [ "$STATUS" = "200" ]; then
            echo "Version $VERSION already exists on PyPI, skipping"
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "Version $VERSION not on PyPI, will publish"
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install system dependencies
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libsasl2-dev libldap2-dev libssl-dev libxmlsec1-dev \
            pkg-config

      - name: Install upstream Python dependencies
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          cd upstream
          pip install -r requirements.txt
          pip install drf-spectacular

      - name: Extract OpenAPI schema
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          cd upstream
          python ../publisher/scripts/extract_schema.py . ../publisher/schema.json

      - name: Install openapi-python-client
        if: steps.check-pypi.outputs.exists == 'false'
        run: pip install openapi-python-client

      - name: Generate client
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          cd publisher
          openapi-python-client generate \
            --path schema.json \
            --config generator_config.yml

      - name: Patch package metadata
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          cd publisher
          python scripts/patch_package.py tandoor-client "${{ steps.version.outputs.version }}" \
            --repo-url "${{ github.server_url }}/${{ github.repository }}" \
            --upstream-url "${{ github.server_url }}/${{ vars.UPSTREAM_REPO }}"

      - name: Build package
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          cd publisher/tandoor-client
          pip install build
          python -m build

      - name: Smoke test
        if: steps.check-pypi.outputs.exists == 'false'
        run: |
          cd publisher
          pip install tandoor-client/dist/*.whl
          python scripts/validate_client.py tandoor-client

      - name: Publish to PyPI
        if: steps.check-pypi.outputs.exists == 'false'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: publisher/tandoor-client/dist/

      - name: Create GitHub Release
        if: steps.check-pypi.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          gh release create "v${VERSION}" \
            --repo "${{ github.repository }}" \
            --title "tandoor-client ${VERSION}" \
            --notes "Auto-published from upstream Tandoor Recipes tag ${{ matrix.tag }}." \
            2>/dev/null || echo "Release v${VERSION} already exists, skipping"

  update-state:
    needs: [detect-new-tags, build-and-publish]
    if: needs.detect-new-tags.outputs.has_tags == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Resolve latest tag ref
        id: ref
        run: |
          UPSTREAM="${{ vars.UPSTREAM_URL }}"
          TAG="${{ needs.detect-new-tags.outputs.latest_tag }}"

          ref=$(git ls-remote --tags "$UPSTREAM" "refs/tags/${TAG}^{}" | awk '{print $1}')
          if [ -z "$ref" ]; then
            ref=$(git ls-remote --tags "$UPSTREAM" "refs/tags/${TAG}" | awk '{print $1}')
          fi
          echo "ref=$ref" >> "$GITHUB_OUTPUT"
          echo "Latest tag: $TAG (ref: $ref)"

      - name: Update state
        run: |
          python scripts/compute_version.py \
            --state-file upstream_state.json \
            --upstream-url "${{ vars.UPSTREAM_URL }}" \
            --tag "${{ needs.detect-new-tags.outputs.latest_tag }}" \
            --update-ref "${{ steps.ref.outputs.ref }}" > /dev/null

      - name: Commit state
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add upstream_state.json
          git diff --cached --quiet && exit 0
          git commit -m "chore: update state (${{ needs.detect-new-tags.outputs.latest_tag }})"
          git pull --rebase
          git push
